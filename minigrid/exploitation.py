import gymnasium as gym
import torch
import numpy as np
from minigrid.wrappers import FullyObsWrapper
from customenvs import SimpleBoxesEnv, MazeBoxesEnv
import time
import argparse
from utils import get_state_tensor
from distutils.util import strtobool

import imageio
from PIL import Image, ImageDraw, ImageFont

import sys
sys.path.append('../')

device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

parser = argparse.ArgumentParser()
parser.add_argument("--env-name", type=str, default="SimpleBoxes")
parser.add_argument("--fully-obs", type=lambda x: bool(strtobool(x)), default=False, nargs="?", const=True)
parser.add_argument("--max-timesteps", type=int, default=256)
parser.add_argument("--capture-gif", default=False, action='store_true')
args = parser.parse_args()

env_name = args.env_name
render_mode = "rgb_array" if args.capture_gif else "human"

if env_name == "SimpleBoxes":
    env = SimpleBoxesEnv(render_mode=render_mode)
elif env_name == "MazeBoxes":
    env = MazeBoxesEnv(render_mode=render_mode)
else:
    env = gym.make(env_name, render_mode=render_mode)
if args.fully_obs:
    env = FullyObsWrapper(env)

AGENT_MODEL_NAME = f"trained-models/{env_name}/actor_test_centre_b.pth"
agent = torch.load(AGENT_MODEL_NAME)
max_timesteps = args.max_timesteps

# Array to store frames for gif
frames = []

# Generate trajectories
state = env.reset()[0]
total_return, episode_return, episode_number = 0, 0, 0

def add_text_to_image(img, timestep, episode, episode_reward):

    img_pil = Image.fromarray(img)
    width, height = img_pil.size
    img_pil.resize((width*2, height*2))
    width, height = img_pil.size

    draw = ImageDraw.Draw(img_pil)
    draw.text((5, 5/height), 'Time Step: {}'.format(timestep+1))
    draw.text((0.6 * width, 5/height), 'Episode: {}'.format(episode+1))
    draw.text((0.15 * width, 0.9 * height), 'Episode Reward: {:.1f}'.format(episode_reward))

    return np.array(img_pil)

for t in range(max_timesteps):
    
    if args.capture_gif:
        img = env.render()
        img = add_text_to_image(img, timestep=t, episode=episode_number, episode_reward=episode_return)
        frames.append(img)

    state['image'] = state['image'].reshape(1, *state['image'].shape)
    state['direction'] = np.array([state['direction']])
    obs = get_state_tensor(state)
    action = agent.get_action_and_value(obs)[0].item()
    state, reward, terminated, truncated, info = env.step(action) 
    total_return += reward
    episode_return += reward
    
    if t%128 == 127 or terminated or truncated: 
        state = env.reset()[0]
        print("Episode return:", episode_return)
        episode_return = 0
        episode_number += 1

if args.capture_gif:
    imageio.mimsave('trajectory.gif', frames, duration=0.1)

env.close()
