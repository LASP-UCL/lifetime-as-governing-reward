import gymnasium as gym
import torch
import numpy as np
from minigrid.wrappers import FullyObsWrapper
from customenvs import *
import time
import argparse
from utils import get_state_tensor
from distutils.util import strtobool

import imageio
from PIL import Image, ImageDraw, ImageFont

import sys
sys.path.append('../')

device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

parser = argparse.ArgumentParser()
parser.add_argument("--env-id", type=str, default="EnergyBoxes")
parser.add_argument("--fully-obs", type=lambda x: bool(strtobool(x)), default=False, nargs="?", const=True)
parser.add_argument("--max-timesteps", type=int, default=256)
parser.add_argument("--capture-gif", default=False, action='store_true')
parser.add_argument("--agent-name", default="test")
parser.add_argument("--seed", type=int, default=1)
parser.add_argument("--time-bonus", type=float, default=0.1)
parser.add_argument("--box-reward", type=float, default=0)
parser.add_argument("--random", default=False, action='store_true')
parser.add_argument("--render-mode", type=str, default="human")
args = parser.parse_args()

env_id = args.env_id
render_mode = "rgb_array" if args.capture_gif else args.render_mode

if "Energy" in env_id:

    energy_args = {"render_mode": render_mode,
                    "agent_start_dir": "random",
                    "agent_start_pos": (1,1),
                    "time_bonus": args.time_bonus,
                    "box_open_reward": args.box_reward,
                    "seed": args.seed,
                    "track_timestep_counts": True}
    if env_id == "EnergyBoxes":
        env = EnergyBoxesEnv(**energy_args)
    elif env_id == "EnergyBoxesHard":
        env = EnergyBoxesHardEnv(**energy_args)
    elif env_id == "EnergyBoxesDelay":
        env = EnergyBoxesDelayEnv(**energy_args)
    else:
        raise NotImplementedError(f"Env {env_id} not implemented")

else:
    env = gym.make(env_id, render_mode=render_mode if render_mode in ["rgb_array", "human"] else None)
if args.fully_obs:
    env = FullyObsWrapper(env)

AGENT_MODEL_NAME = f"trained-models/{env_id}/actor_{args.agent_name}.pth"
agent = torch.load(AGENT_MODEL_NAME) if not args.random else None
max_timesteps = args.max_timesteps

# Array to store frames for gif
frames = []

# Generate trajectories
state = env.reset()[0]
total_return, episode_return, episode_number, episode_timestep = 0, 0, 0, 0

def add_text_to_image(img, timestep, episode_timestep, episode, episode_reward, energy=None):

    img_pil = Image.fromarray(img)
    width, height = img_pil.size
    img_pil.resize((width*2, height*2))
    width, height = img_pil.size

    draw = ImageDraw.Draw(img_pil)

    if "Energy" in env_id:
        draw.text((5, 5/height), 'Step: {}'.format(episode_timestep+1))
        draw.text((0.5 * width, 5/height), 'Energy: {}'.format(energy+1))
        draw.text((0.15 * width, 0.9 * height), 'Episode Reward: {:.1f}'.format(episode_reward))
    else:
        draw.text((5, 5/height), 'Time Step: {}'.format(timestep+1))
        draw.text((0.6 * width, 5/height), 'Episode: {}'.format(episode+1))
        draw.text((0.15 * width, 0.9 * height), 'Episode Reward: {:.1f}'.format(episode_reward))

    return np.array(img_pil)

for t in range(max_timesteps):

    kwargs = {}
    episode_timestep += 1

    if "Energy" in env_id:
        current_energy = env.energy-1
        kwargs["energy"] = current_energy
    
    state['image'] = state['image'].reshape(1, *state['image'].shape)
    state['direction'] = np.array([state['direction']])
    obs = get_state_tensor(state)
    if args.random: 
        action = env.action_space.sample()
        action = 4
        time.sleep(0.5)
    else: 
        action = agent.get_action_and_value(obs)[0].item()
    state, reward, terminated, truncated, info = env.step(action) 
    total_return += reward
    episode_return += reward

    if args.capture_gif:
        img = env.render()
        img = add_text_to_image(img, timestep=t, 
                                    episode_timestep=episode_timestep,
                                    episode=episode_number, 
                                    episode_reward=episode_return,
                                    **kwargs)
        frames.append(img)

    if terminated or truncated: 
        state = env.reset()[0]
        print(f"\n{t}: Episode return: {episode_return:.2f}, Episode length: {episode_timestep}")
        episode_return = 0
        episode_number += 1
        episode_timestep = 0

if args.capture_gif:
    imageio.mimsave(f'outputs/trajectory-{args.agent_name}.gif', frames, duration=0.1)

# save dict timestep_counts in outputs dir
if "Energy" in env_id:
    timestep_counts = info['timestep_counts']
    np.save(f"outputs/timestep_counts-{args.agent_name}.npy", timestep_counts)
    print(info['timestep_counts'])

env.close()
