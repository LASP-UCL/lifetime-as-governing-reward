import gym
import minihack
from nle import nethack
import tqdm
import torch
import torch.nn as nn
import numpy as np
import matplotlib.pyplot as plt
import time
import pygame
import IPython.display

import sys
sys.path.append('../')
from models import DiscreteActorNet

device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
MODEL_PATH = 'actor.pt'
HIDDEN_SIZE = 32
MAX_TIMESTEPS = 1000


# Restrict actions to movement and navigation
MOVE_ACTIONS = tuple(nethack.CompassDirection)

# Define room minihack environment
env = gym.make('MiniHack-Room-15x15-v0',
               actions=MOVE_ACTIONS,
               observation_keys=("glyphs", "chars", "colors")
)

print("Observation space:", env.observation_space)
print("Action space:", env.action_space)

# Load model
actor_net = torch.load('actor.pth')

# Initialise environment state
state = env.reset()
state_tensor = torch.cat([torch.tensor(state[key].flatten(), dtype=torch.float32) for key in state.keys()])
total_reward, ep = 0, 0
render_strings = []

for step in range(MAX_TIMESTEPS):
    action = actor_net.get_action(state_tensor)[0]
    state, reward, done, _ = env.step(action)
    state_tensor = torch.cat([torch.tensor(state[key].flatten(), dtype=torch.float32) for key in state.keys()])
    total_reward += reward

    if not done:
        env_render = env.render(mode='ansi')
        env_render = env_render.replace(' ', '').replace('>', '.').replace('<', '.')
        env_render = env_render[env_render.find("."):env_render.rfind(".")+1]
        render_strings.append(env_render)

    if done:
        print(f"Episode {ep} finished | Reward {total_reward}\n")
        break
        state = env.reset()
        state_tensor = torch.cat([torch.tensor(state[key].flatten(), dtype=torch.float32) for key in state.keys()])
        ep += 1
        total_reward = 0
        time.sleep(1)
env.close()


# Write render strings to file
with open('render_strings.txt', 'w') as f:
    for render_string in render_strings:
        f.write(render_string + '\n\n')
"""
# Create gif from render output
import matplotlib.pyplot as plt
import imageio
import os

images = []
for render_string in render_strings:
    # each render string is a text string of the current state of the environment
    # we can use this to create each frame of the gif
    # transform the string into an image using matplotlib
    images.append(plt.imread(render_string))
    
imageio.mimsave('render.gif', images)
"""